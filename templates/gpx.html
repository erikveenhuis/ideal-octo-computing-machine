{% extends "base.html" %}

{% block title %}GPX Route Viewer{% endblock %}

{% block extra_head %}
<link href="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css" rel="stylesheet" />
<style>
    .map-container {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #f3f4f6;
        position: relative; /* Create positioning context */
    }
    .dark .map-container {
        background-color: #374151;
    }
    .map-wrapper {
        /* Always maintain 8.5:11 aspect ratio */
        aspect-ratio: 8.5 / 11;
        /* Perfect size for clean 3x scaling to print (850x3=2550, 1100x3=3300) */
        width: 850px;
        height: auto; /* Height will be 1100px due to 8.5:11 aspect ratio */
        border: 2px solid #111;
        border-radius: 4px;
        overflow: hidden;
        /* Absolute positioning within the map-container */
        position: absolute;
        /* Center within the container space (to the right of sidebar) */
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        transition: transform .2s ease-out;
    }
    #map {
        width: 100%;
        height: 100%;
        border: none;
    }
    .marker-info {
        font-size: 12px;
        padding: 4px 8px;
        background-color: white;
        border-radius: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    .sidebar {
        transition: all 0.3s ease-out;
        height: 100%;
    }
    .sidebar-content {
        transition: all 0.3s ease-out;
        height: calc(100% - 3rem);
    }
    .sidebar.collapsed .sidebar-content {
        height: 0;
        opacity: 0;
        margin: 0;
        padding: 0;
    }
    .toggle-sidebar {
        display: none;
    }

    /* Clean up - no mobile support needed since we show message instead */
    @media print {
        .sidebar, .sidebar-content, .controls, .nav-links, #message, .mapboxgl-control-container {
            display: none !important;
        }
        .map-container {
            background: white !important;
            padding: 0 !important;
        }
        .map-wrapper {
            max-width: none !important;
            width: 100vw !important; 
            height: 90vh !important;
            aspect-ratio: none !important;
            border: 2px solid #111 !important;
            margin: 0 auto !important;
            page-break-after: avoid;
        }
    }

    /* Hide all Mapbox attribution elements completely */
    .mapboxgl-ctrl-attrib,
    .mapboxgl-ctrl-attrib-inner,
    .mapboxgl-ctrl-attrib-button,
    .mapboxgl-ctrl-logo,
    .mapbox-improve-map {
        display: none !important;
        visibility: hidden !important;
    }
</style>
{% endblock %}

{% block content %}
<!-- Message for small screens -->
<div class="lg:hidden flex items-center justify-center h-[calc(100vh-4rem)] bg-gray-50 dark:bg-gray-900 p-6">
    <div class="text-center max-w-md">
        <svg class="mx-auto h-16 w-16 text-gray-400 dark:text-gray-500 mb-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
        </svg>
        <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">Desktop Experience Required</h2>
        <p class="text-gray-600 dark:text-gray-300 mb-4">
            The GPX Route Viewer is optimized for desktop and tablet screens. For the best experience with map viewing, route editing, and high-quality exports, please use a device with a screen width of at least 1024 pixels.
        </p>
        <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
            <p class="text-sm text-blue-800 dark:text-blue-200">
                <strong>Minimum recommended:</strong> 1024px width<br>
                <strong>Optimal experience:</strong> 1280px+ width
            </p>
        </div>
    </div>
</div>

<div class="hidden lg:block relative h-[calc(100vh-4rem)] overflow-hidden">
    <!-- Fixed sidebar on the left -->
    <div class="fixed left-0 top-16 w-80 h-[calc(100vh-4rem)] bg-gray-50 dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700 z-10">
        <div class="sidebar h-full">
            <button class="toggle-sidebar text-gray-700 dark:text-gray-300 lg:hidden">
                <span class="font-medium">Controls</span>
                <svg class="w-5 h-5 transform transition-transform duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
            </button>
            <div class="sidebar-content p-4 h-[calc(100%-3rem)] lg:h-full">
                <div class="flex flex-col h-full">
                    <div class="upload-section flex-shrink-0 mb-4">
                        <h2 class="text-lg font-medium text-gray-900 dark:text-white mb-2">Upload GPX File</h2>
                        <form id="uploadForm">
                            <input type="file" id="gpxFile" accept=".gpx" required
                                class="w-full px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white">
                        </form>
                    </div>

                    <div class="controls space-y-2 flex-shrink-0">
                        <div class="flex items-center justify-between">
                            <label class="text-sm font-medium text-gray-700 dark:text-gray-300">Show Start/Finish</label>
                            <button id="toggleMarkers" 
                                class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900 bg-blue-600 dark:bg-blue-700">
                                <span class="translate-x-5 pointer-events-none relative inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out">
                                    <span class="absolute inset-0 flex h-full w-full items-center justify-center transition-opacity" aria-hidden="true">
                                        <svg class="h-3 w-3 text-gray-400" fill="none" viewBox="0 0 12 12">
                                            <path d="M4 8l2-2m0 0l2-2M6 6L4 4m2 2l2 2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                                        </svg>
                                    </span>
                                </span>
                            </button>
                        </div>

                        <div class="flex items-center justify-between">
                            <label class="text-sm font-medium text-gray-700 dark:text-gray-300">Route color:</label>
                            <input type="color" id="routeColor" value="#e74c3c" 
                                class="h-8 w-8 rounded-md border border-gray-300 dark:border-gray-600">
                        </div>
                        <div class="flex items-center justify-between">
                            <label class="text-sm font-medium text-gray-700 dark:text-gray-300">Route width:</label>
                            <input type="number" id="routeWidth" value="5" min="1" max="20" 
                                class="w-20 px-2 py-1 border border-gray-300 dark:border-gray-600 rounded-md focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white">
                        </div>

                        <div class="flex items-center justify-between">
                            <label class="text-sm font-medium text-gray-700 dark:text-gray-300">Map style:</label>
                            <select id="mapStyle" 
                                class="w-40 px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:text-white">
                                <option value="forex" selected>Forex</option>
                                <option value="plexiglas">Plexiglas</option>
                                <option value="plexiglas_black">Plexiglas Black</option>
                            </select>
                        </div>

                        <div class="flex items-center justify-between">
                            <label class="text-sm font-medium text-gray-700 dark:text-gray-300">Export quality:</label>
                            <select id="exportQuality" 
                                class="w-40 px-2 py-1 bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:text-white">
                                <option value="standard">Standard (300 DPI)</option>
                                <option value="high">High (400 DPI)</option>
                                <option value="ultra" selected>Ultra (450 DPI)</option>
                                <option value="maximum">Maximum (600 DPI)</option>
                            </select>
                        </div>

                        <div class="flex items-center justify-between">
                            <label class="text-sm font-medium text-gray-700 dark:text-gray-300">Anti-aliasing:</label>
                            <button id="toggleAntialiasing" type="button" 
                                class="relative inline-flex h-6 w-11 items-center rounded-full bg-blue-600 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900">
                                <span class="inline-block h-4 w-4 transform rounded-full bg-white transition-transform translate-x-6"></span>
                            </button>
                        </div>

                        <button id="saveImageBtn" 
                            class="w-full px-4 py-2 bg-gray-900 dark:bg-gray-700 text-white rounded-md hover:bg-gray-800 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 dark:focus:ring-offset-gray-900">
                            Save as PNG
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    
    <!-- Map area with left margin for fixed sidebar -->
    <div class="ml-80 h-full">
        <div class="map-container">
            <div class="map-wrapper">
                <div id="map"></div>
            </div>
        </div>
    </div>
</div>
</div>
{% endblock %}

{% block extra_scripts %}
<script src="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Set the access token
    mapboxgl.accessToken = '{{ config.MAPBOX_ACCESS_TOKEN }}';

    const mapStyles = {
        'forex': 'mapbox://styles/erikveenhuis/cmb9e07eg00ui01sd37h67oui',
        'plexiglas': 'mapbox://styles/erikveenhuis/cmb9esh6700u701r41sxu3dnr',
        'plexiglas_black': 'mapbox://styles/erikveenhuis/cmbkgyte200or01s5dtabce0c'
    };

    // Initialize the map with enhanced rendering settings
    const map = new mapboxgl.Map({
        container: 'map',
        // The style is set dynamically below to apply necessary runtime fixes.
        center: [5.2913, 52.1326], // Note: Mapbox uses [lng, lat] order
        zoom: 7,
        attributionControl: false, // Remove attribution for cleaner export
        preserveDrawingBuffer: true, // Essential for canvas export
        fadeDuration: 0, // Disable fade animations for better export
        antialias: true, // Enable antialiasing for smoother rendering
        optimizeForTerrain: true, // Optimize rendering for terrain
        maxTileCacheSize: 200, // Increase tile cache for better performance
        transformRequest: (url, resourceType) => {
            // Request higher resolution tiles when available
            if (resourceType === 'Source' && url.includes('mapbox://') && url.includes('/tiles/')) {
                return {
                    url: url.replace(/\.png/, '@2x.png')  // Request 2x resolution tiles
                }
            }
        }
    });

    async function setAndFixStyle(styleUrl) {
        // Convert mapbox:// URL to a fetchable URL for the Styles API
        const styleId = styleUrl.replace('mapbox://styles/', '');
        const fetchUrl = `https://api.mapbox.com/styles/v1/${styleId}?access_token=${mapboxgl.accessToken}`;

        try {
            const response = await fetch(fetchUrl);
            if (!response.ok) {
                throw new Error(`Failed to fetch style: ${response.statusText}`);
            }
            const style = await response.json();

            // Recursively traverse the style object to fix expressions that expect a 'len' property.
            // This prevents rendering errors when base map features don't have this property.
            function fixLenExpression(obj) {
                if (Array.isArray(obj)) {
                    // Find the problematic ["get", "len"] expression
                    if (obj.length === 2 && obj[0] === 'get' && obj[1] === 'len') {
                        // Replace it with a 'coalesce' expression to provide a fallback value of 0.
                        return ['coalesce', ['get', 'len'], 0];
                    }
                    return obj.map(fixLenExpression);
                }
                if (obj !== null && typeof obj === 'object') {
                    const newObj = {};
                    for (const key in obj) {
                        if (Object.prototype.hasOwnProperty.call(obj, key)) {
                           newObj[key] = fixLenExpression(obj[key]);
                        }
                    }
                    return newObj;
                }
                return obj; // Return primitive values as-is
            }

            const modifiedStyle = fixLenExpression(style);
            map.setStyle(modifiedStyle);

        } catch (error) {
            console.error('Error loading or modifying map style:', error);
            // As a fallback, try to set the original style URL if modification fails.
            map.setStyle(styleUrl);
        }
    }

    // Handle missing images in the style, like 'marker'. This prevents errors when a style
    // references an image that is not in its sprite sheet.
    map.on('styleimagemissing', (e) => {
        const id = e.id;
        // Create a dummy 1x1 transparent image to prevent errors.
        const width = 1;
        const height = 1;
        const data = new Uint8Array(width * height * 4);
        map.addImage(id, { width, height, data });
    });

    let currentStyle = 'forex';
    let routeSource = null;
    let routeLayer = null;
    let markersSource = null;
    let showMarkers = true;
    let antialiasing = true;
    
    // Quality settings for different export levels - Fixed to maintain same view area
    const qualitySettings = {
        'standard': { dpi: 300, pixelRatio: 1.0, unsharpAmount: 80 },
        'high': { dpi: 400, pixelRatio: 1.33, unsharpAmount: 100 },
        'ultra': { dpi: 450, pixelRatio: 1.5, unsharpAmount: 120 },
        'maximum': { dpi: 600, pixelRatio: 2.0, unsharpAmount: 150 }
    };

    function cleanupMapData() {
        // Remove layers in reverse order of dependency
        if (map.getLayer('marker-circles')) map.removeLayer('marker-circles');
        if (map.getLayer('markers')) map.removeLayer('markers');
        if (map.getLayer('route')) map.removeLayer('route');

        // Remove sources after their dependent layers are gone
        if (map.getSource('markers')) map.removeSource('markers');
        if (map.getSource('route')) map.removeSource('route');

        // Reset state variables
        routeSource = null;
        routeLayer = null;
        markersSource = null;
    }

    // Add navigation controls
    map.addControl(new mapboxgl.NavigationControl());

    // Handle file upload
    document.getElementById('gpxFile').addEventListener('change', async (e) => {
        const fileInput = e.target;
        
        if (!fileInput.files.length) {
            showToast('Please select a file', 'error');
            return;
        }

        const formData = new FormData();
        formData.append('gpx_file', fileInput.files[0]);

        try {
            // Ensure the map is clean before adding new data.
            cleanupMapData();

            const response = await fetch('/upload-gpx', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token() }}'
                },
                body: formData
            });
            
            const data = await response.json();
            
            if (data.error) {
                showToast(data.error, 'error');
                return;
            }

            // Create GeoJSON for the route
            const coordinates = data.track_points.map(point => [point.lon, point.lat]);
            routeSource = {
                type: 'geojson',
                data: {
                    type: 'Feature',
                    properties: {},
                    geometry: {
                        type: 'LineString',
                        coordinates: coordinates
                    }
                }
            };

            routeLayer = {
                id: 'route',
                type: 'line',
                source: 'route',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': document.getElementById('routeColor').value,
                    'line-width': parseInt(document.getElementById('routeWidth').value, 10),
                    'line-opacity': 0.7
                }
            };

            // Add the route to the map
            map.addSource('route', routeSource);
            map.addLayer(routeLayer);

            // Add markers if enabled
            if (showMarkers && coordinates.length > 0) {
                // Create SVG markers for start and finish
                const routeColor = document.getElementById('routeColor').value;
                
                // Create GeoJSON for markers
                markersSource = {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: [
                            {
                                type: 'Feature',
                                properties: {
                                    'marker-symbol': 'S',
                                    'marker-color': routeColor
                                },
                                geometry: {
                                    type: 'Point',
                                    coordinates: coordinates[0]
                                }
                            },
                            {
                                type: 'Feature',
                                properties: {
                                    'marker-symbol': 'F',
                                    'marker-color': routeColor
                                },
                                geometry: {
                                    type: 'Point',
                                    coordinates: coordinates[coordinates.length - 1]
                                }
                            }
                        ]
                    }
                };

                // Add markers source and layer
                map.addSource('markers', markersSource);
                
                // Add circle background layer
                map.addLayer({
                    id: 'marker-circles',
                    type: 'circle',
                    source: 'markers',
                    paint: {
                        'circle-radius': 10,
                        'circle-color': ['get', 'marker-color']
                    }
                });
                
                // Add text layer on top
                map.addLayer({
                    id: 'markers',
                    type: 'symbol',
                    source: 'markers',
                    layout: {
                        'text-field': ['get', 'marker-symbol'],
                        'text-size': 12,
                        'text-anchor': 'center',
                        'text-allow-overlap': true,
                        'icon-image': 'none'
                    },
                    paint: {
                        'text-color': '#ffffff'
                    }
                });
            }

            // Fit bounds to the route
            const bounds = coordinates.reduce((bounds, coord) => {
                return bounds.extend(coord);
            }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

            // Add padding to the bounds before fitting
            const paddedBounds = bounds.extend([
                bounds.getSouthWest().lng - 0.01,
                bounds.getSouthWest().lat - 0.01
            ]);

            map.fitBounds(paddedBounds, {
                padding: {
                    top: 50,
                    bottom: 100,
                    left: 50,
                    right: 50
                },
                duration: 1000,
                maxZoom: 15
            });

            showToast('Route loaded successfully!', 'success');
        } catch (error) {
            showToast('Error loading GPX file: ' + error.message, 'error');
        }
    });

    // Handle color and width changes
    document.getElementById('routeColor').addEventListener('input', function() {
        if (routeLayer) {
            map.setPaintProperty('route', 'line-color', this.value);
            // Update marker colors if they exist
            if (map.getSource('markers')) {
                const markersSource = map.getSource('markers');
                const data = markersSource.serialize().data;
                data.features.forEach(feature => {
                    feature.properties['marker-color'] = this.value;
                });
                markersSource.setData(data);
            }
        }
    });

    document.getElementById('routeWidth').addEventListener('input', function() {
        if (routeLayer) {
            map.setPaintProperty('route', 'line-width', parseInt(this.value, 10));
        }
    });

    // Handle map style change
    document.getElementById('mapStyle').addEventListener('change', function() {
        const newStyle = this.value;
        setAndFixStyle(mapStyles[newStyle]);
        currentStyle = newStyle;
    });

    map.on('styledata', () => {
        // When a new style is loaded, re-add the route and markers if they exist.
        if (routeSource && !map.getSource('route')) {
            map.addSource('route', routeSource);
            map.addLayer(routeLayer);
        }
        if (showMarkers && markersSource && !map.getSource('markers')) {
            map.addSource('markers', markersSource);
            map.addLayer({
                id: 'marker-circles',
                type: 'circle',
                source: 'markers',
                paint: {
                    'circle-radius': 10,
                    'circle-color': ['get', 'marker-color']
                }
            });
            map.addLayer({
                id: 'markers',
                type: 'symbol',
                source: 'markers',
                layout: {
                    'text-field': ['get', 'marker-symbol'],
                    'text-size': 12,
                    'text-anchor': 'center',
                    'text-allow-overlap': true,
                    'icon-image': 'none'
                },
                paint: {
                    'text-color': '#ffffff'
                }
            });
        }
        setTimeout(() => {
            map.resize();
        }, 300);
    });

    // Handle marker toggle
    document.getElementById('toggleMarkers').addEventListener('click', function() {
        showMarkers = !showMarkers;
        this.classList.toggle('bg-blue-600');
        this.classList.toggle('bg-gray-200');
        this.classList.toggle('dark:bg-blue-700');
        this.classList.toggle('dark:bg-gray-700');
        
        const span = this.querySelector('span');
        if (showMarkers) {
            span.classList.remove('translate-x-0');
            span.classList.add('translate-x-5');
        } else {
            span.classList.remove('translate-x-5');
            span.classList.add('translate-x-0');
        }
        
        // Toggle both marker layers visibility
        if (map.getLayer('markers')) {
            map.setLayoutProperty('markers', 'visibility', showMarkers ? 'visible' : 'none');
        }
        if (map.getLayer('marker-circles')) {
            map.setLayoutProperty('marker-circles', 'visibility', showMarkers ? 'visible' : 'none');
        }
    });

    // Handle antialiasing toggle
    document.getElementById('toggleAntialiasing').addEventListener('click', function() {
        antialiasing = !antialiasing;
        this.classList.toggle('bg-blue-600');
        this.classList.toggle('bg-gray-200');
        this.classList.toggle('dark:bg-blue-700');
        this.classList.toggle('dark:bg-gray-700');
        
        const span = this.querySelector('span');
        if (antialiasing) {
            span.classList.remove('translate-x-0');
            span.classList.add('translate-x-5');
        } else {
            span.classList.remove('translate-x-5');
            span.classList.add('translate-x-0');
        }
    });

    // Function to add DPI metadata to PNG
    function addPngDpiMetadata(pngData, pixelsPerMeter) {
        try {
            // PNG signature: 89 50 4E 47 0D 0A 1A 0A
            if (pngData[0] !== 0x89 || pngData[1] !== 0x50 || pngData[2] !== 0x4E || pngData[3] !== 0x47) {
                throw new Error('Not a valid PNG file');
            }
            
            // Find the IDAT chunk to insert pHYs before it
            let insertPosition = 8; // Start after PNG signature
            
            while (insertPosition < pngData.length - 8) {
                const chunkLength = (pngData[insertPosition] << 24) | (pngData[insertPosition + 1] << 16) | 
                                  (pngData[insertPosition + 2] << 8) | pngData[insertPosition + 3];
                const chunkType = String.fromCharCode(pngData[insertPosition + 4], pngData[insertPosition + 5], 
                                                    pngData[insertPosition + 6], pngData[insertPosition + 7]);
                
                if (chunkType === 'IDAT') {
                    break;
                }
                
                insertPosition += 8 + chunkLength + 4; // 8 bytes header + data + 4 bytes CRC
            }
            
            // Create pHYs chunk
            const physChunk = new Uint8Array(21); // 4 length + 4 type + 9 data + 4 CRC
            
            // Length (9 bytes)
            physChunk[0] = 0x00;
            physChunk[1] = 0x00;
            physChunk[2] = 0x00;
            physChunk[3] = 0x09;
            
            // Type "pHYs"
            physChunk[4] = 0x70; // p
            physChunk[5] = 0x48; // H
            physChunk[6] = 0x59; // Y
            physChunk[7] = 0x73; // s
            
            // Data: pixels per unit X (4 bytes) + pixels per unit Y (4 bytes) + unit specifier (1 byte)
            physChunk[8] = (pixelsPerMeter >>> 24) & 0xFF;
            physChunk[9] = (pixelsPerMeter >>> 16) & 0xFF;
            physChunk[10] = (pixelsPerMeter >>> 8) & 0xFF;
            physChunk[11] = pixelsPerMeter & 0xFF;
            
            physChunk[12] = (pixelsPerMeter >>> 24) & 0xFF;
            physChunk[13] = (pixelsPerMeter >>> 16) & 0xFF;
            physChunk[14] = (pixelsPerMeter >>> 8) & 0xFF;
            physChunk[15] = pixelsPerMeter & 0xFF;
            
            physChunk[16] = 0x01; // Unit: meters
            
            // Calculate CRC32 for type + data
            const crc = calculateCRC32(physChunk.slice(4, 17));
            physChunk[17] = (crc >>> 24) & 0xFF;
            physChunk[18] = (crc >>> 16) & 0xFF;
            physChunk[19] = (crc >>> 8) & 0xFF;
            physChunk[20] = crc & 0xFF;
            
            // Insert pHYs chunk
            const result = new Uint8Array(pngData.length + 21);
            result.set(pngData.slice(0, insertPosition));
            result.set(physChunk, insertPosition);
            result.set(pngData.slice(insertPosition), insertPosition + 21);
            
            return result;
        } catch (error) {
            console.warn('Failed to add DPI metadata:', error);
            return pngData; // Return original if modification fails
        }
    }
    
    // Simple CRC32 calculation for PNG chunks
    function calculateCRC32(data) {
        const crcTable = new Array(256);
        for (let i = 0; i < 256; i++) {
            let c = i;
            for (let j = 0; j < 8; j++) {
                c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
            }
            crcTable[i] = c;
        }
        
        let crc = 0xFFFFFFFF;
        for (let i = 0; i < data.length; i++) {
            crc = crcTable[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
        }
        return (crc ^ 0xFFFFFFFF) >>> 0;
    }

    // Save as Image functionality
    if (!saveImageBtn) {
        console.error('Save as Image button not found!');
    } else {
        saveImageBtn.addEventListener('click', async function() {
            try {
                // Get selected quality settings first
                const selectedQuality = document.getElementById('exportQuality').value;
                const quality = qualitySettings[selectedQuality];
                const dpi = quality.dpi;
                
                showToast(`🗺️ Preparing ${selectedQuality} quality export (${dpi} DPI)...`, 'success');
                
                // Wait for map to be completely loaded and styled
                await new Promise((resolve, reject) => {
                    let timeout = setTimeout(() => {
                        reject(new Error('Timeout waiting for map to load'));
                    }, 15000); // 15 second timeout
                    
                    const checkMapReady = () => {
                        // Check if map is loaded, style is loaded, and no ongoing style operations
                        if (map.loaded() && map.isStyleLoaded() && !map._isStyleLoading) {
                            clearTimeout(timeout);
                            console.log('Map is fully ready for export');
                            showToast('📷 Capturing your route in high resolution...', 'success');
                            resolve();
                        } else {
                            console.log('Map not ready:', {
                                loaded: map.loaded(),
                                styleLoaded: map.isStyleLoaded(),
                                styleLoading: map._isStyleLoading
                            });
                            // Keep checking every 100ms
                            setTimeout(checkMapReady, 100);
                        }
                    };
                    
                    checkMapReady();
                });
                
                // Additional delay to ensure all rendering is complete
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Keep canvas dimensions consistent to maintain same view area
                const baseWidth = 850;
                const baseHeight = 1100;
                const exportCanvasWidth = baseWidth;   // Always 850px
                const exportCanvasHeight = baseHeight; // Always 1100px
                
                // Dynamic print dimensions based on selected DPI
                const finalWidth = Math.round(8.5 * dpi);   // 8.5" * DPI
                const finalHeight = Math.round(11 * dpi);   // 11" * DPI
                
                // Store current map state with high precision
                const currentCenter = map.getCenter();
                const currentZoom = map.getZoom();
                const currentBearing = map.getBearing();
                const currentPitch = map.getPitch();
                
                // Store center with maximum precision to avoid any drift
                const preciseCenter = [currentCenter.lng, currentCenter.lat];
                
                console.log('Capturing state - Center:', preciseCenter, 'Zoom:', currentZoom);
                
                console.log('Using exact zoom level:', currentZoom);
                console.log('Export canvas size (consistent):', exportCanvasWidth, 'x', exportCanvasHeight);
                console.log('Pixel ratio for quality:', quality.pixelRatio);
                console.log('Final print size:', finalWidth, 'x', finalHeight);
                
                // Create temporary container with exact same styling as on-screen
                const exportContainer = document.createElement('div');
                exportContainer.style.width = exportCanvasWidth + 'px';
                exportContainer.style.height = exportCanvasHeight + 'px';
                exportContainer.style.position = 'absolute';
                exportContainer.style.top = '-10000px'; // Hide off-screen
                exportContainer.style.left = '-10000px';
                exportContainer.style.border = 'none';
                exportContainer.style.padding = '0';
                exportContainer.style.margin = '0';
                exportContainer.style.boxSizing = 'content-box';
                document.body.appendChild(exportContainer);
                
                // Get pixel ratio from current map for exact rendering match
                const pixelRatio = map.getCanvas().style.pixelRatio || window.devicePixelRatio || 1;
                
                // Create temporary map with exact same view but higher pixel density
                const exportMap = new mapboxgl.Map({
                    container: exportContainer,
                    style: map.getStyle(),
                    center: preciseCenter, // Use precise center coordinates
                    zoom: currentZoom, // Exact same zoom level
                    bearing: currentBearing,
                    pitch: currentPitch,
                    preserveDrawingBuffer: true,
                    fadeDuration: 0,
                    interactive: false,
                    // Enhanced rendering settings with higher pixel ratio for quality
                    antialias: antialiasing,
                    failIfMajorPerformanceCaveat: false,
                    pixelRatio: quality.pixelRatio, // Higher pixel ratio = more pixels for same view
                    attributionControl: false, // Match on-screen map - no attribution for cleaner export
                    optimizeForTerrain: true,
                    maxTileCacheSize: 300, // Increased cache for high-quality export
                    // Request higher resolution tiles for export
                    transformRequest: (url, resourceType) => {
                        if (resourceType === 'Source' && url.includes('/tiles/') && url.includes('.png')) {
                            return {
                                url: url.replace(/\.png/, '@2x.png')  // Request 2x tiles for better quality
                            }
                        }
                    }
                });
                
                // Export map will have no controls to match the on-screen map
                
                // Track added images to prevent duplicates
                const addedImages = new Set();
                
                // Handle missing images that could cause rendering differences
                exportMap.on('styleimagemissing', (e) => {
                    if (!addedImages.has(e.id)) {
                        console.log('Handling missing image:', e.id);
                        addedImages.add(e.id);
                        // Create a 1x1 transparent pixel as fallback for missing images
                        const img = new Image(1, 1);
                        img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=';
                        img.onload = () => {
                            try {
                                exportMap.addImage(e.id, img);
                            } catch (err) {
                                console.log('Image already exists:', e.id);
                            }
                        };
                    }
                });
                
                // Wait for export map to load completely
                await new Promise((resolve, reject) => {
                    let timeout = setTimeout(() => {
                        reject(new Error('Timeout waiting for export map to load'));
                    }, 20000);
                    
                    const checkExportMapReady = () => {
                        if (exportMap.loaded() && exportMap.isStyleLoaded()) {
                            clearTimeout(timeout);
                            console.log('Export map is ready');
                            resolve();
                        } else {
                            setTimeout(checkExportMapReady, 100);
                        }
                    };
                    
                    checkExportMapReady();
                });
                
                // Triple synchronization approach to eliminate any drift
                // First: Set position immediately after load
                exportMap.setCenter(preciseCenter);
                exportMap.setZoom(currentZoom);
                exportMap.setBearing(currentBearing);
                exportMap.setPitch(currentPitch);
                
                // Wait for initial positioning to settle
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Second: Force synchronization with on-screen map again
                const currentState = {
                    center: [map.getCenter().lng, map.getCenter().lat],
                    zoom: map.getZoom(),
                    bearing: map.getBearing(),
                    pitch: map.getPitch()
                };
                
                // Apply southward adjustment to compensate for navigation controls
                // The navigation controls in the on-screen map effectively shift the visual center
                const adjustedCenter = [
                    currentState.center[0], // longitude unchanged
                    currentState.center[1] - 0.0019 // latitude shifted more noticeably south
                ];
                
                console.log('Applying southward adjustment to export center:', adjustedCenter);
                console.log('Keeping zoom identical for same detail level:', currentState.zoom);
                
                exportMap.setCenter(adjustedCenter);
                exportMap.setZoom(currentState.zoom); // Keep zoom identical for same detail level
                exportMap.setBearing(currentState.bearing);
                exportMap.setPitch(currentState.pitch);
                
                // Wait for second positioning to settle
                await new Promise(resolve => setTimeout(resolve, 400));
                
                // Third: Final verification and micro-adjustment if needed
                const exportState = {
                    center: [exportMap.getCenter().lng, exportMap.getCenter().lat],
                    zoom: exportMap.getZoom()
                };
                
                // Check for any drift and correct it (but maintain the southward adjustment)
                const centerDrift = Math.abs(exportState.center[0] - adjustedCenter[0]) + 
                                  Math.abs(exportState.center[1] - adjustedCenter[1]);
                const zoomDrift = Math.abs(exportState.zoom - currentState.zoom);
                
                if (centerDrift > 0.000001 || zoomDrift > 0.001) {
                    console.log('Detected drift, applying final correction with adjustment');
                    exportMap.setCenter(adjustedCenter); // Use adjusted center, not original
                    exportMap.setZoom(currentState.zoom); // Keep zoom identical for same detail level
                    exportMap.setBearing(currentState.bearing);
                    exportMap.setPitch(currentState.pitch);
                    
                    // Additional settling time after correction
                    await new Promise(resolve => setTimeout(resolve, 600));
                }
                
                // CRITICAL: Ensure route data is synchronized to export map
                if (routeSource && routeLayer) {
                    console.log('Synchronizing route data to export map');
                    
                    // Add the same route source and layer to export map
                    if (!exportMap.getSource('route')) {
                        exportMap.addSource('route', routeSource);
                        exportMap.addLayer(routeLayer);
                    }
                    
                    // Also add markers if they exist and are visible
                    if (showMarkers && markersSource && !exportMap.getSource('markers')) {
                        exportMap.addSource('markers', markersSource);
                        
                        // Add marker layers in same order as on-screen map
                        exportMap.addLayer({
                            id: 'marker-circles',
                            type: 'circle',
                            source: 'markers',
                            paint: {
                                'circle-radius': 10,
                                'circle-color': ['get', 'marker-color']
                            }
                        });
                        
                        exportMap.addLayer({
                            id: 'markers',
                            type: 'symbol',
                            source: 'markers',
                            layout: {
                                'text-field': ['get', 'marker-symbol'],
                                'text-size': 12,
                                'text-anchor': 'center',
                                'text-allow-overlap': true,
                                'icon-image': 'none'
                            },
                            paint: {
                                'text-color': '#ffffff'
                            }
                        });
                        
                        // Match marker visibility state
                        if (!showMarkers) {
                            exportMap.setLayoutProperty('markers', 'visibility', 'none');
                            exportMap.setLayoutProperty('marker-circles', 'visibility', 'none');
                        }
                    }
                    
                    console.log('Route data synchronized successfully');
                }
                
                // Final rendering stabilization delay after route sync
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Comprehensive verification of positioning and canvas state
                const exportCenter = exportMap.getCenter();
                const exportCanvas = exportMap.getCanvas();
                
                console.log('=== FINAL VERIFICATION ===');
                console.log('On-screen center:', [map.getCenter().lng, map.getCenter().lat]);
                console.log('Export center:', [exportCenter.lng, exportCenter.lat]);
                console.log('Center difference (lng, lat):', 
                    (exportCenter.lng - map.getCenter().lng).toFixed(8), 
                    (exportCenter.lat - map.getCenter().lat).toFixed(8));
                    
                console.log('On-screen zoom:', map.getZoom().toFixed(6));
                console.log('Export zoom:', exportMap.getZoom().toFixed(6));
                console.log('Zoom difference:', (exportMap.getZoom() - map.getZoom()).toFixed(6));
                
                console.log('Expected canvas size:', exportCanvasWidth, 'x', exportCanvasHeight);
                console.log('Actual export canvas size:', exportCanvas.width, 'x', exportCanvas.height);
                console.log('Canvas size difference:', exportCanvas.width - exportCanvasWidth, exportCanvas.height - exportCanvasHeight);
                
                console.log('Export map loaded:', exportMap.loaded());
                console.log('Export map style loaded:', exportMap.isStyleLoaded());
                console.log('=== END VERIFICATION ===');
                
                const canvas = exportMap.getCanvas();
                
                console.log('Export canvas dimensions:', canvas.width, 'x', canvas.height);
                console.log('Canvas pixel ratio:', quality.pixelRatio);
                console.log('Canvas physical size:', canvas.width, 'x', canvas.height);
                console.log('Canvas buffer size:', canvas.width * window.devicePixelRatio, 'x', canvas.height * window.devicePixelRatio);
                console.log('Same view area with higher pixel density for better quality!');
                
                if (!canvas) {
                    throw new Error('Map canvas not available');
                }
                
                // Test if canvas can export data directly
                let testDataUrl;
                try {
                    testDataUrl = canvas.toDataURL('image/png');
                    console.log('Test export data URL length:', testDataUrl.length);
                    
                    if (testDataUrl.length < 1000) {
                        throw new Error('Canvas appears to be blank - data URL too short');
                    }
                    
                    console.log('Canvas export test successful - canvas has content');
                } catch (e) {
                    console.error('Canvas export test failed:', e);
                    throw new Error('Canvas cannot be exported. Error: ' + e.message);
                }
                
                showToast('🖨️ Creating your high-quality print (this may take a moment)...', 'success');
                
                // Check if pica is available for high-quality scaling
                if (typeof pica === 'undefined') {
                    throw new Error('Pica library not loaded. Please refresh the page.');
                }
                
                // The canvas already contains high-DPI content due to pixelRatio setting
                // Scale directly to final print size, maintaining quality
                console.log('Canvas actual size:', canvas.width, 'x', canvas.height);
                console.log('Canvas contains', quality.pixelRatio, 'x pixel density');
                console.log('Scaling to final print size:', finalWidth, 'x', finalHeight);
                
                // Create final board-sized canvas for print
                const boardCanvas = document.createElement('canvas');
                boardCanvas.width = finalWidth;
                boardCanvas.height = finalHeight;
                
                // Scale the high-DPI canvas to final print size
                await pica().resize(canvas, boardCanvas, {
                    quality: 3,        // Highest quality (Lanczos)
                    alpha: true,       // Preserve transparency
                    unsharpAmount: quality.unsharpAmount, // Dynamic unsharp masking based on quality level
                    unsharpRadius: 0.8, // Slightly larger radius for better edge definition
                    unsharpThreshold: 1, // Lower threshold for more aggressive sharpening
                    transferable: true  // Use transferable objects for better performance
                });
                
                // Convert to blob and add DPI metadata
                const blob = await new Promise(resolve => {
                    boardCanvas.toBlob(async (blob) => {
                        try {
                            // Convert blob to array buffer
                            const arrayBuffer = await blob.arrayBuffer();
                            const uint8Array = new Uint8Array(arrayBuffer);
                            
                            // Add pHYs chunk for DPI metadata (dynamic DPI based on quality setting)
                            const dpiMeters = Math.round(dpi * 39.3701); // Convert DPI to pixels per meter
                            const modifiedPng = addPngDpiMetadata(uint8Array, dpiMeters);
                            
                            // Create new blob with DPI metadata
                            resolve(new Blob([modifiedPng], { type: 'image/png' }));
                        } catch (error) {
                            console.warn('Could not add DPI metadata:', error);
                            // Fall back to original blob
                            resolve(blob);
                        }
                    }, 'image/png', 1.0);
                });
                
                // Clean up export map and container
                exportMap.remove();
                document.body.removeChild(exportContainer);
                
                // Create download link with dynamic filename
                const link = document.createElement('a');
                link.download = `gpx-route-${new Date().toISOString().split('T')[0]}-${dpi}dpi-${selectedQuality}.png`;
                link.href = URL.createObjectURL(blob);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Clean up object URL
                setTimeout(() => URL.revokeObjectURL(link.href), 1000);
                
                showToast(`✅ Success! Your route is ready to print at ${dpi} DPI ${selectedQuality} quality`, 'success', 4000);
                
            } catch (error) {
                console.error(`Error during ${dpi} DPI ${selectedQuality} export:`, error);
                showToast('❌ Export failed - please try again or check your internet connection', 'error', 5000);
            }
        });
    }

    // Toggle sidebar on mobile
    document.querySelector('.toggle-sidebar').addEventListener('click', function() {
        const sidebar = document.querySelector('.sidebar');
        const icon = this.querySelector('svg');
        sidebar.classList.toggle('collapsed');
        icon.classList.toggle('rotate-180');
        
        // Trigger a resize event to ensure the map updates its size
        setTimeout(() => {
            map.resize();
        }, 300);
    });

    // Handle map resize
    window.addEventListener('resize', () => {
        map.resize();
    });

    // Initial style load
    setAndFixStyle(mapStyles[currentStyle]);
});
</script>
{% endblock %} 